/*		UDP Packet forwarder for internet connected HIL
 *
 * 		File:				callbacks.c
 * 		Author(s): 			15 May 2018
 * 		Creation Date:		P L Evans
 *
 * 		Description:
 *		Functions to handle signals generated by GUI widget signals
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <glib.h>

#include "udpfwd.h"
#include "peprintf.h"

G_MODULE_EXPORT void UFD_openPort( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;
	char *text;
	int port;

	/* Get IP Address / ports chosen by user */
	if( !(text = gtk_entry_get_text( GTK_ENTRY( ud->widgets[WIDGET_HILIP]) )) ) {
		peprintf( PEPSTR_ERROR, NULL, "Error retrieving specified HIL IP\n" );
		return;
	}

	strncpy( ud->localHILIP, text, 127 );

	if( !(text = gtk_entry_get_text( GTK_ENTRY( ud->widgets[WIDGET_HILPORT]) )) ) {
		peprintf( PEPSTR_ERROR, NULL, "Error retrieving specified HIL Port\n" );
		return;
	}

	strncpy( ud->localHILPort, text, 63 );

	if( !(text = gtk_entry_get_text( GTK_ENTRY( ud->widgets[WIDGET_LOCALPORT]) )) ) {
		peprintf( PEPSTR_ERROR, NULL, "Error retrieving specified local Port\n" );
		return;
	}

	strncpy( ud->localPort, text, 63 );

	port = atoi( ud->localPort );
	if( strlen(ud->localPort) <= 0 ) {
		peprintf( PEPSTR_ERROR, NULL, "Invalid Local Port\n" );
		return;
	}
	port = atoi( ud->localHILPort );
	if( strlen(ud->localHILPort) <= 0 ) {
		peprintf( PEPSTR_ERROR, NULL, "Invalid HIL Port\n" );
		return;
	}

	/* Start a thread to handle listening for data from local HIL */
	peprintf( PEPSTR_HILI, NULL, "Starting local comms listening thread...\n" );
	ud->runLocalThread = 1;
	if( !g_thread_new( "SimulationThread",(GThreadFunc) &UFD_localRecvThread, userdata ) ) {
		peprintf( PEPSTR_ERROR, NULL, "Failed to fork local comms thread\n" );
		ud->runLocalThread = 0;
	}


	/* Create a socket to handle sending data to local HIL */
	peprintf( PEPSTR_HILI, NULL, "Creating socket for sending data to local HIL (IP:%s, Port:%d)...\n", ud->localHILIP, port );
	ud->HILSockLen = sizeof(ud->HILSockAddr);


	//create socket
	if ( ( ud->localHILSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR ) {
		peprintf( PEPSTR_ERROR, NULL, "socket() failed with error code : %d" , WSAGetLastError());
		return;
	}

	//setup address structure
	memset((char *) &ud->HILSockAddr, 0, sizeof(ud->HILSockAddr));
	ud->HILSockAddr.sin_family = AF_INET;
	ud->HILSockAddr.sin_port = htons( port );
	ud->HILSockAddr.sin_addr.S_un.S_addr = inet_addr( ud->localHILIP );

	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENULOCALSTOP], TRUE );
	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENULOCALSTART], FALSE );

	UFD_enableHILIP( ud, FALSE );
	UFD_enableBroadcast( ud, TRUE );
}


G_MODULE_EXPORT void UFD_closePort( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;

	peprintf( PEPSTR_HILI, NULL, "Attemping to close listening port for local HIL...\n" );

	ud->runLocalThread = 0;
	ud->enableEmulation = 0;

	closesocket( ud->localHILSocket );
	ud->HILSockLen = 0;

	//while( ud->localThreadActive );

	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENULOCALSTOP], FALSE );
	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENULOCALSTART], TRUE );
	UFD_enableHILIP( ud, TRUE );
	UFD_enableBroadcast( ud, FALSE );
}


G_MODULE_EXPORT void UFD_enableRemote( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;

	peprintf( PEPSTR_HILI, NULL, "Remote boradcast enabled\n" );
}

G_MODULE_EXPORT void UFD_disableRemote( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;

	peprintf( PEPSTR_HILI, NULL, "Remote broadcast disabled\n" );
}

G_MODULE_EXPORT void UFD_addRemote( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;

	peprintf( PEPSTR_HILI, NULL, "Remote address added\n" );
}

G_MODULE_EXPORT void UFD_removeRemote( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;

	peprintf( PEPSTR_HILI, NULL, "Remote address removed\n" );
}


G_MODULE_EXPORT void UFD_broadcastMessage( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;
	char *msg;
	int id;
	double value;
	const char *str;
	uint64_t timestamp;

	UdpParameter params[9];
	int nparam = 0;

	char buf[RECV_BUFFER_LENGTH];
	int buflen;

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTTS]) );
	timestamp = atoi(str);

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID1]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE1]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID2]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE2]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID3]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE3]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID4]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE4]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID5]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE5]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID6]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE6]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID7]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE7]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID8]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE8]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID9]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE9]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	if( nparam > 0 ) {
		buflen = UFD_encodeBuffer( buf, params, nparam, timestamp );

		peprintf( PEPSTR_INFO, NULL, "Transmitting %d bytes\n", buflen );

		/* TODO: Broadcast to remote HIL ports using defined VCHV message format */
		if( sendto( ud->localHILSocket, buf, buflen, 0, (struct sockaddr *) &ud->HILSockAddr, ud->HILSockLen ) == SOCKET_ERROR ) {
			peprintf( PEPSTR_ERROR, NULL, "sendto() failed with error code : %d" , WSAGetLastError() );
			return;
		}

		peprintf( PEPSTR_INFO, NULL, "Packet sent: %d variables, %d bytes\n", nparam, buflen );
	} else {
		peprintf( PEPSTR_INFO, NULL, "Packet not sent, no parameters specified\n" );
	}
}




