/*		UDP Packet forwarder for internet connected HIL
 *
 * 		File:				callbacks.c
 * 		Author(s): 			15 May 2018
 * 		Creation Date:		P L Evans
 *
 * 		Description:
 *		Functions to handle signals generated by GUI widget signals
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <glib.h>

#include "udpfwd.h"
#include "peprintf.h"

G_MODULE_EXPORT void UFD_openPort( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;
	char *text;
	int port;

	/* Get IP Address / ports chosen by user */
	if( !(text = gtk_entry_get_text( GTK_ENTRY( ud->widgets[WIDGET_HILIP]) )) ) {
		peprintf( PEPSTR_ERROR, NULL, "Error retrieving specified HIL IP\n" );
		return;
	}

	strncpy( ud->localHILIP, text, 127 );

	if( !(text = gtk_entry_get_text( GTK_ENTRY( ud->widgets[WIDGET_HILPORT]) )) ) {
		peprintf( PEPSTR_ERROR, NULL, "Error retrieving specified HIL Port\n" );
		return;
	}

	strncpy( ud->localHILPort, text, 63 );

	if( !(text = gtk_entry_get_text( GTK_ENTRY( ud->widgets[WIDGET_LOCALPORT]) )) ) {
		peprintf( PEPSTR_ERROR, NULL, "Error retrieving specified local Port\n" );
		return;
	}

	strncpy( ud->localPort, text, 63 );

	port = atoi( ud->localPort );
	if( strlen(ud->localPort) <= 0 ) {
		peprintf( PEPSTR_ERROR, NULL, "Invalid Local Port\n" );
		return;
	}
	port = atoi( ud->localHILPort );
	if( strlen(ud->localHILPort) <= 0 ) {
		peprintf( PEPSTR_ERROR, NULL, "Invalid HIL Port\n" );
		return;
	}

	/* Start a thread to handle listening for data from local HIL */
	peprintf( PEPSTR_HILI, NULL, "Starting local comms listening thread...\n" );
	ud->runLocalThread = 1;
	if( !g_thread_new( "SimulationThread",(GThreadFunc) &UFD_localRecvThread, userdata ) ) {
		peprintf( PEPSTR_ERROR, NULL, "Failed to fork local comms thread\n" );
		ud->runLocalThread = 0;
	}


	/* Create a socket to handle sending data to local HIL */
	peprintf( PEPSTR_HILI, NULL, "Creating socket for sending data to local HIL (IP:%s, Port:%d)...\n", ud->localHILIP, port );
	ud->HILSockLen = sizeof(ud->HILSockAddr);


	//create socket
	if ( ( ud->localHILSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR ) {
		peprintf( PEPSTR_ERROR, NULL, "socket() failed with error code : %d" , WSAGetLastError());
		return;
	}

	//setup address structure
	memset((char *) &ud->HILSockAddr, 0, sizeof(ud->HILSockAddr));
	ud->HILSockAddr.sin_family = AF_INET;
	ud->HILSockAddr.sin_port = htons( port );
	ud->HILSockAddr.sin_addr.S_un.S_addr = inet_addr( ud->localHILIP );

	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENULOCALSTOP], TRUE );
	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENULOCALSTART], FALSE );

	UFD_enableHILIP( ud, FALSE );
	UFD_enableBroadcast( ud, TRUE );
}


G_MODULE_EXPORT void UFD_closePort( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;
	//char buf[1];

	//buf[0] = 0x01;

	peprintf( PEPSTR_HILI, NULL, "Attemping to close listening port for local HIL...\n" );

	ud->runLocalThread = 0;
	closesocket( ud->recvHILSocket );

	closesocket( ud->localHILSocket );
	ud->HILSockLen = 0;

	//while( ud->localThreadActive );

	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENULOCALSTOP], FALSE );
	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENULOCALSTART], TRUE );
	UFD_enableHILIP( ud, TRUE );
	UFD_enableBroadcast( ud, FALSE );
}


G_MODULE_EXPORT void UFD_enableRemote( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;
	char *text;
	int port;

	UFD_enableRemoteList( ud, FALSE );

	if( !(text = gtk_entry_get_text( GTK_ENTRY( ud->widgets[WIDGET_INTERNETPORT]) )) ) {
		peprintf( PEPSTR_ERROR, NULL, "Error retrieving specified internet Port\n" );
		return;
	}

	strncpy( ud->remotePort, text, 63 );

	if( strlen(ud->remotePort) <= 0 ) {
		peprintf( PEPSTR_ERROR, NULL, "Invalid internet listening Port\n" );
		return;
	}

	/* Start a thread to handle listening for data from local HIL */
	peprintf( PEPSTR_HILI, NULL, "Starting remote comms listening thread...\n" );
	ud->runRemoteThread = 1;
	if( !g_thread_new( "SimulationThread",(GThreadFunc) &UFD_remoteRecvThread, userdata ) ) {
		peprintf( PEPSTR_ERROR, NULL, "Failed to fork local comms thread\n" );
		ud->runRemoteThread = 0;
	}

	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENUREMOTESTOP], TRUE );
	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENUREMOTESTART], FALSE );
	gtk_widget_set_sensitive( ud->widgets[WIDGET_INTERNETPORT], FALSE );

}


G_MODULE_EXPORT void UFD_disableRemote( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;
	//char buf[1];

	//buf[0] = 0x01;

	peprintf( PEPSTR_HILI, NULL, "Attemping to close listening port for local HIL...\n" );

	ud->runRemoteThread = 0;
	closesocket( ud->recvInternetSocket );

	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENUREMOTESTOP], FALSE );
	gtk_widget_set_sensitive( ud->widgets[WIDGET_MENUREMOTESTART], TRUE );
	gtk_widget_set_sensitive( ud->widgets[WIDGET_INTERNETPORT], TRUE );

	UFD_enableRemoteList( ud, TRUE );
}

G_MODULE_EXPORT void UFD_addRemote( GtkWidget *button, gpointer userdata ) {
	UdpFwdData *ud = (UdpFwdData*) userdata;
	GtkTreeIter iter;
	const char *ipStr;
	const char *portStr;
	int rid;

	ipStr = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_REMOTEIP]) );
	portStr = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_REMOTEPORT]) );

	if( ipStr && strlen(ipStr) > 6 && portStr && strlen(portStr) > 0 ) {
		peprintf( PEPSTR_HILI, NULL, "Creating socket for transmitting to remote %s:%s...", ipStr, portStr );

		/* Add connection structure to main data structure */
		rid = ud->nRemotes++;
		if( !(ud->remotes = realloc( ud->remotes, ud->nRemotes*sizeof(UdpRemoteConnection))) ) {
			ud->nRemotes--;
			peprintf( PEPSTR_ERROR, NULL, "Failed to allocated for new remote connection\n" );
			return;
		}

		/* Create a socket to handle sending data to local HIL */
		ud->remotes[rid].sockLen = sizeof(ud->HILSockAddr);

		/* create socket */
		if ( ( ud->remotes[rid].socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR ) {
			peprintf( PEPSTR_ERROR, NULL, "socket() failed with error code : %d\n" , WSAGetLastError());
			return;
		}

		/* setup address structure */
		memset( (char*) &ud->remotes[rid].sockAddr, 0, sizeof(ud->HILSockAddr) );
		ud->remotes[rid].sockAddr.sin_family = AF_INET;
		ud->remotes[rid].sockAddr.sin_port = htons( atoi(portStr) );
		ud->remotes[rid].sockAddr.sin_addr.S_un.S_addr = inet_addr( ipStr );

		strcpy( ud->remotes[rid].ipStr, ipStr );
		strcpy( ud->remotes[rid].portStr, portStr );

		/* Add to visible list */
		gtk_tree_store_append( GTK_TREE_STORE((GtkTreeStore*)ud->widgets[WIDGET_REMOTESTORE]), &iter, NULL );
		gtk_tree_store_set( GTK_TREE_STORE((GtkTreeStore*)ud->widgets[WIDGET_REMOTESTORE]), &iter, 0, ipStr, 1, portStr, 2, rid, -1 );

		peprintf( PEPSTR_HILI, NULL, "done\n" );
		gtk_entry_set_text( GTK_ENTRY(ud->widgets[WIDGET_REMOTEIP]), "" );
		gtk_entry_set_text( GTK_ENTRY(ud->widgets[WIDGET_REMOTEPORT]), "" );
	} else {
		peprintf( PEPSTR_WARN, NULL, "Not adding remote, port or IP invalid\n" );
	}
}

G_MODULE_EXPORT void UFD_removeRemote( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;
	GtkTreeSelection *select;
	GtkTreeIter iter;
	GtkTreeModel *model;
	int id = -1;
	int i;

	select = gtk_tree_view_get_selection( GTK_TREE_VIEW(ud->widgets[WIDGET_REMOTELIST]) );

	/* Get the tree model (list_store) and initialise the iterator */
	if( !select || !gtk_tree_selection_get_selected( select, &model, &iter ) ) return;

	/* Get the selected entity */
	gtk_tree_model_get( GTK_TREE_MODEL((GtkTreeStore*)ud->widgets[WIDGET_REMOTESTORE]), &iter, 2, &id, -1 );

	/* Close socket and remove remote from internal list */
	if( id < 0 || id >= ud->nRemotes ) {
		peprintf( PEPSTR_WARN, NULL, "Selected remote ID seems to be out-of-range\n" );
	} else {
		ud->nRemotes--;

		closesocket( ud->remotes[id].socket );

		for( i = id; i < ud->nRemotes; i++ ) {
			ud->remotes[i] = ud->remotes[i+1];
		}

		ud->remotes = realloc( ud->remotes, ud->nRemotes*sizeof(UdpRemoteConnection) );
	}

	/* Clear list and re-add remaining sockets */
	gtk_tree_store_clear( GTK_TREE_MODEL((GtkTreeStore*)ud->widgets[WIDGET_REMOTESTORE]) );

	for( i = 0; i < ud->nRemotes; i++ ) {
		gtk_tree_store_append( GTK_TREE_STORE((GtkTreeStore*)ud->widgets[WIDGET_REMOTESTORE]), &iter, NULL );
		gtk_tree_store_set( GTK_TREE_STORE((GtkTreeStore*)ud->widgets[WIDGET_REMOTESTORE]), &iter, 0, ud->remotes[i].ipStr, 1, ud->remotes[i].portStr, 2, i, -1 );
	}
}


G_MODULE_EXPORT void UFD_broadcastMessage( GtkWidget *button, gpointer userdata ) {
	UdpFwdData* ud = (UdpFwdData*) userdata;
	char *msg;
	int id;
	double value;
	const char *str;
	uint64_t timestamp;

	UdpParameter params[9];
	int nparam = 0;

	char buf[RECV_BUFFER_LENGTH];
	int buflen;

	UdpParameterList *pl;

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTTS]) );
	timestamp = atoi(str);

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID1]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE1]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID2]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE2]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID3]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE3]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID4]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE4]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID5]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE5]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID6]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE6]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID7]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE7]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID8]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE8]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTID9]) );
	id = atoi(str);
	if( id >= 0 ) {
		str = gtk_entry_get_text( GTK_ENTRY(ud->widgets[WIDGET_BROADCASTVALUE9]) );
		value = atof(str);
		params[nparam].ID = id;
		params[nparam].value = value;
		params[nparam++].timestamp = timestamp;
	}

	if( nparam > 0 ) {
		buflen = UFD_triphase_encodeBuffer( buf, params, nparam, timestamp );

		peprintf( PEPSTR_INFO, NULL, "Transmitting to HIL\n" );
		if( UFD_sendPacketToHIL( ud, buf, buflen ) ) {
			peprintf( PEPSTR_INFO, NULL, " - Packet sent: %d variables, %d bytes\n", nparam, buflen );
		}

		buflen = UFD_internet_encodeBuffer( buf, params, nparam, timestamp );

		peprintf( PEPSTR_INFO, NULL, "Transmitting to remotes\n" );
		if( UFD_broadcastPacketToRemotes( ud, buf, buflen ) ) {
			peprintf( PEPSTR_INFO, NULL, " - Packet sent: %d variables, %d bytes\n", nparam, buflen );
		}

		pl = malloc( sizeof( UdpParameterList) );

		if( pl ) {
			pl->params = malloc( nparam * sizeof(UdpParameter) );
			if( pl->params ) {
				memcpy( pl->params, params, nparam * sizeof(UdpParameter) );
				pl->nparams = nparam;
				gdk_threads_add_idle( UFD_updateGUIRecvParams_thread, pl );
			} else {
				free( pl );
				peprintf( PEPSTR_ERROR, NULL, "Error allocating for parameter list\n" );
			}
		} else {
			peprintf( PEPSTR_ERROR, NULL, "Error allocating for parameter list\n" );
		}
	} else {
		peprintf( PEPSTR_INFO, NULL, "Packet not sent, no parameters specified\n" );
	}
}





